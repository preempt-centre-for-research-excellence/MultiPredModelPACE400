---
title: "PACE_400_multimodal"
author: "Simon Hartmann"
date: "07/12/2021"
output:
  word_document: default
  pdf_document: default
  html_notebook: default
  html_document:
    df_print: paged
always_allow_html: true
editor_options:
  chunk_output_type: inline
---

# Load packages

```{r, include=FALSE}
# Load packages -----------------
library(readxl)
library(tidyverse)
library(zoo)
library(kableExtra)
library(reshape2)
library(ggpubr)
library(caret)
library(rms)

library(glmnet)
library(boot)
library(cowplot)

library(survival)
library(survminer)
library(sva)
```

## Define functions to calculate correlations and PCA table

```{r}
#### PCA table function #####
#### Input: data frame for table, column index, PCA summaries for both hemispheres
#### Output: ggplot object
pca.table <- function(table.tmp, ind, a, b) {
  tmp.a <- summary(a)
  tmp.b <- summary(b)
  table.tmp[1:20,ind] <- c(tmp.a$importance['Proportion of Variance',c(1:10)], tmp.b$importance['Proportion of Variance',c(1:10)])
  return(table.tmp)
}

#### Function to calculate lambda for LASSO regression #####
#### Input: summary from cross-validation procedure, tolerance value
#### Output: optimized lambda

get_lambda <- function(fit, tol = .5) {
  error <- fit$cvm[fit$lambda == fit$lambda.min]
  sd <- fit$cvsd[fit$lambda == fit$lambda.min]
  tolerance <- error + tol*sd
  max(fit$lambda[fit$cvm < tolerance])
}

#### PCA variance plot function #####
#### Input: PCA results, title
#### Output: ggplot object

pca_plot <- function(plot.data, title){
  
  tmp.plot <- ggplot(plot.data, aes(x = x, y = value, group = variable)) + 
    geom_line(aes(color = variable), size = 1.1) +
    geom_point(aes(color = variable), size = 3) +
    scale_x_continuous(name ="First ten principal components", breaks = c(1:10),
                limits=c(1,10)) +
    scale_y_continuous(name="% of variance explained", breaks = c(0,25,50,75), limits=c(0, 75)) +
    theme_bw() +
    scale_color_brewer(palette="Set1") +
    ggtitle(title) + 
    labs(color = 'Cortical measure') +
    theme(plot.title = element_text(size = 18, hjust = 0.5),
         axis.title.x = element_text(size = 16),
         axis.title.y = element_text(size = 16),
         legend.text = element_text(size = 14),
         legend.title = element_text(size = 16),
         axis.text.x = element_text(size = 14),
         axis.text.y = element_text(size = 14)) +
    theme(legend.position="bottom")
  return(tmp.plot)
}

#### PCA loading plot function #####
#### Input: loading values for domain in each hemisphere, title
#### Output: ggplot object

loading_plot <- function(domain.data.lh, domain.data.rh, title){

  load_lh <- domain.data.lh$rotation[,1]
  lh_best <- as.data.frame(abs(load_lh[names(sort(abs(load_lh), decreasing = TRUE)[1:10])]))
  lh_best$area <- rownames(lh_best) %>%   strsplit( "_" ) %>%   sapply( "[", 2 )
  colnames(lh_best) <- c('Loading', 'Area')
  lh_best$Area <- factor(lh_best$Area, levels = lh_best$Area)
  
  load_rh <- domain.data.rh$rotation[,1]
  rh_best <- as.data.frame(abs(load_rh[names(sort(abs(load_rh), decreasing = TRUE)[1:10])]))
  rh_best$area <- rownames(rh_best) %>%   strsplit( "_" ) %>%   sapply( "[", 2 )
  colnames(rh_best) <- c('Loading', 'Area')
  rh_best$Area <- factor(rh_best$Area, levels = rh_best$Area)
  
  left_loading <- ggplot(lh_best, aes(x=Loading, y=Area))+
    geom_bar(stat="identity", width=0.7, fill="steelblue")+
    theme_minimal() +
    scale_y_discrete(name ="Cortical segments", limits=rev, labels = ) +
    scale_x_continuous(name="Factor loading onto PC1", breaks = c(0, 0.1, 0.2, 0.3), limits=c(0,0.3)) +
    ggtitle('Left hemisphere') +
    theme(plot.title = element_text(size = 18, hjust = 0.5),
       axis.title.x = element_text(size = 16),
       axis.title.y = element_text(size = 16),
       legend.text = element_text(size = 14),
       legend.title = element_text(size = 16),
       axis.text.x = element_text(size = 14),
       axis.text.y = element_text(size = 14)) 
  
  right_loading <- ggplot(rh_best, aes(x=Loading, y=Area))+
    geom_bar(stat="identity", width=0.7, fill="steelblue")+
    theme_minimal() +
    scale_y_discrete(name ="Cortical segments", limits=rev, labels = ) +
    scale_x_continuous(name="Factor loading onto PC1", breaks = c(0, 0.1, 0.2, 0.3), limits=c(0,0.3)) +
    ggtitle('Right hemisphere') +
    theme(plot.title = element_text(size = 18, hjust = 0.5),
       axis.title.x = element_text(size = 16),
       axis.title.y = element_text(size = 16),
       legend.text = element_text(size = 14),
       legend.title = element_text(size = 16),
       axis.text.x = element_text(size = 14),
       axis.text.y = element_text(size = 14)) 
  
  plot.loading <- ggarrange(left_loading, right_loading, ncol = 2 )
  plot.loading <- annotate_figure(plot.loading, top = text_grob(title, 
                 face = "bold", size = 20))
  
  return(plot.loading)
}

#### Cox model function #####
#### Input: predictors for Cox model, row index for table, tables, additional predictors (optional)
#### Output: summary and overfitting table

cox_model <- function(cox.bl, i, cox.table, overfit.table, ...){

  x = list(...)
  # Get bootstrapped model
  bl.conf <- bootcov(cox.bl, B=1000, pr=TRUE)
  # Extract regression parameters for each predictor
  bl.an <- anova(bl.conf)
  # Store regression summary
  bl.summ <- summary(bl.conf, pre.cond = 3)
  # Internal validation using bootstrapping
  bl.val <- validate(cox.bl, method="boot", B=1000, bw=FALSE)
  # Store overfitting values
  overfit.table[i,] <- c(bl.val['Dxy', 'optimism'], bl.val['R2','optimism'], bl.val['Slope','optimism'])
  
  if (length(x) > 0){
    bl.p <- lrtest(x[[1]], bl.conf)
  
    cox.table[i,] <- c(bl.summ[2,4], bl.an[1,3], bl.summ[4,4], bl.an[2,3], bl.summ[10,4], bl.an[3,3],bl.summ[12,4], bl.an[3,3], bl.summ[6,4], bl.an[4,3], bl.summ[8,4], bl.an[5,3], cox.bl$stats['Model L.R.'], bl.p$stats['P'], 1-(x[[2]]/cox.bl$stats['Model L.R.']), bl.val['Dxy', 'index.corrected']/2 + 0.5)
    
    return(list(cox.table, overfit.table))
  }else{
    # Store regression results
    cox.table[i,] <- c(bl.summ[2,4], bl.an[1,3], bl.summ[4,4], bl.an[2,3], bl.summ[6,4], bl.an[3,3], bl.summ[8,4], bl.an[3,3], 0, 0, 0, 0, LR.orig, 0, 1, bl.val['Dxy',   'index.corrected']/2 + 0.5)
    return(list(cox.table, overfit.table))
  }
  
}

#### Calibration plot function #####
#### Input: predictors for Cox model, timepoint
#### Output: ggplot object

calibration_plot <- function(S, timepace, gaf, caarms.cd, caarms.tc, pre.cond, pc1.thick, pc2.thick, t){
  
  set.seed(123)

  dd <- datadist(timepace, gaf, caarms.cd, caarms.tc, pre.cond, pc1.thick, pc2.thick)
  options(datadist='dd')
  
  bl <- cph(S ~ timepace + gaf + pre.cond , x=TRUE, y=TRUE, surv = TRUE, time.inc = t*12)
  bl.caarms <- cph(S ~ timepace + gaf + pre.cond  + caarms.tc + caarms.cd, x=TRUE, y=TRUE, surv = TRUE, time.inc = t*12)
  bl.thick <- cph(S ~ timepace + gaf + pre.cond  + pc1.thick + pc2.thick,  x=TRUE, y=TRUE, surv=TRUE, time.inc = t*12)
  
  bl.cal <- calibrate(bl.thick, method = "boot", u= t*12, m=10, B=1000, bw=FALSE)
  bl.caarms.cal <- calibrate(bl.caarms, method = "boot", u= t*12, m=10, B=1000, bw=FALSE)
  bl.base.cal <- calibrate(bl, method = "boot", u= t*12, m=10, B=1000, bw=FALSE)
  
  
  pred <- as.data.frame(1 - bl.cal[,'pred'])
  
  colnames(pred) <- c('x')
  
  cal.correct <- as.data.frame(1 - bl.cal[,'calibrated.corrected'])
  colnames(cal.correct) <- c('Value')
  cal.correct$Type <- 'MRI'
  
  pred2 <- as.data.frame(1 - bl.base.cal[,'pred'])
  colnames(pred2) <- c('x')
  
  cal.base.correct <- as.data.frame(1 - bl.base.cal[,'calibrated.corrected'])
  colnames(cal.base.correct) <- c('Value')
  cal.base.correct$Type <- 'clinical'
  
  pred3 <- as.data.frame(1 - bl.caarms.cal[,'pred'])
  colnames(pred3) <- c('x')
  
  cal.caarms.correct <- as.data.frame(1 - bl.caarms.cal[,'calibrated.corrected'])
  colnames(cal.caarms.correct) <- c('Value')
  cal.caarms.correct$Type <- 'with CAARMS'
  
  cal_plot_data <- rbind(cbind(pred,cal.correct), cbind(pred2, cal.base.correct), cbind(pred3, cal.caarms.correct))

  cal.plot <- ggplot(cal_plot_data, aes(x = x, y = Value, group = Type)) + 
         geom_line(aes(color = Type), size = 1.1) +
         scale_x_continuous(name =paste("Predicted ", as.character(t),"-year Probability of Transition to Psychosis",sep = ""), breaks = c(0.2,0.4,0.6,0.8), limits=c(0, 0.9)) +
         scale_y_continuous(name=paste("Observed ", as.character(t),"-year Probability of Transition to Psychosis",sep = ""), breaks = c(0.2,0.4,0.6,0.8), limits=c(0, 0.9)) +
         theme_bw() +
         labs(color = '') +
         geom_abline(aes(intercept = 0, slope = 1, color='black'))	+
          scale_color_manual(values = c("black" = "black", "clinical" = "#1b9e77",  "with CAARMS" = "#d95f02", "MRI" = "#7570b3"),
                             labels = c("ideal",  "base", "base + Cognition", "base + CAARMS subscales")) +
         theme(plot.title = element_text(size = 18, hjust = 0.5),
               axis.title.x = element_text(size = 16),
               axis.title.y = element_text(size = 16),
               legend.text = element_text(size = 14),
               legend.title = element_text(size = 16),
               axis.text.x = element_text(size = 14),
               axis.text.y = element_text(size = 14)) +
         theme(legend.position="bottom")
  
  return(cal.plot)
  
  
}

calibration_plot_all <- function(S, timepace, gaf, caarms.cd, caarms.tc, pre.cond){
  
  set.seed(123)

  dd <- datadist(timepace, gaf, caarms.cd, caarms.tc, pre.cond)
  options(datadist='dd')
  
  bl <- cph(S ~ timepace + gaf + pre.cond + caarms.cd + caarms.tc , x=TRUE, y=TRUE, surv = TRUE, time.inc = 2*12)
  
  bl.base.cal <- calibrate(bl, method = "boot", u= 2*12, m=10, B=1000, bw=FALSE)
  
  
  pred <- as.data.frame(1 - bl.base.cal[,'pred'])
  colnames(pred) <- c('x')
  
  cal.base.correct <- as.data.frame(1 - bl.base.cal[,'calibrated.corrected'])
  colnames(cal.base.correct) <- c('Value')
  cal.base.correct$Type <- paste("year",as.character(2), sep = " ")
  
  cal_plot_data <- cbind(pred, cal.base.correct)
  
  for (t in c(4,8,12)){
  
    bl <- cph(S ~ timepace + gaf + pre.cond + caarms.cd + caarms.tc , x=TRUE, y=TRUE, surv = TRUE, time.inc = t*12)
    
    bl.base.cal <- calibrate(bl, method = "boot", u= t*12, m=10, B=1000, bw=FALSE)
    
    pred <- as.data.frame(1 - bl.base.cal[,'pred'])
    colnames(pred) <- c('x')
    
    cal.base.correct <- as.data.frame(1 - bl.base.cal[,'calibrated.corrected'])
    colnames(cal.base.correct) <- c('Value')
    if (t == 12){
      cal.base.correct$Type <- paste("zear",as.character(t), sep = " ")
    }else{
      cal.base.correct$Type <- paste("year",as.character(t), sep = " ")
    }
    
    cal_plot_data <- rbind(cal_plot_data, cbind(pred, cal.base.correct))
  
  }
  
  cal.plot <- ggplot(cal_plot_data, aes(x = x, y = Value, group = Type)) + 
         geom_line(aes(color = Type), size = 1.1) +
         scale_x_continuous(name =paste("Predicted Probability of Transition to Psychosis",sep = ""), breaks = c(0.2,0.4,0.6,0.8), limits=c(0, 0.9)) +
         scale_y_continuous(name=paste("Observed Probability of Transition to Psychosis",sep = ""), breaks = c(0.2,0.4,0.6,0.8), limits=c(0, 0.9)) +
         theme_bw() +
         labs(color = '') +
         geom_abline(aes(intercept = 0, slope = 1, color="black"))	+
         scale_color_manual(values = c( "black" = "black", "year 2" = "#a6cee3", "year 4" = "#1f78b4", "year 8" = "#b2df8a", "zear 12" = "#33a02c"),
                             labels = c( "ideal", "year 2", "year 4", "year 8", "year 12"),
                                     guide = guide_legend(override.aes = list(pch = c(16, NA, NA, NA, NA), linetype = c(1, 1, 1, 1, 1)))) +
         theme(plot.title = element_text(size = 18, hjust = 0.5),
               axis.title.x = element_text(size = 16),
               axis.title.y = element_text(size = 16),
               legend.text = element_text(size = 14),
               legend.title = element_text(size = 16),
               axis.text.x = element_text(size = 14),
               axis.text.y = element_text(size = 14)) +
         theme(legend.position="bottom")
  
  return(cal.plot)
  
  
}
```

## Load data
```{r, , echo=FALSE}
#### LOAD DATA #####
# Load clinical measures
PACE_bl <- read_excel("path\to\baseline\file")

# Load follow-up data
PACE_fup <- read_excel("path\to\follow up data")
# Load MRI Quality Control data
PACE_MRIQC <- read_excel("path\to\MRI\Quality Control file")
# Load look-up table MRI ID and PACE 400 ID
caseid_MRI <- read_excel("path\to\MRI look up table")

# Load MRI thickness data
PACE_MRIthick <- read.delim("path\to\Freesurfer\thickness\data",header = TRUE, sep = ",")
# Load MRI curvature data
PACE_MRIcurve <- read.delim("path\to\Freesurfer\curvature\data",header = TRUE, sep = ",")
# Load MRI surface data
PACE_MRIsurf <- read.delim("path\to\Freesurfer\surface\data",header = TRUE, sep = ",")
#Load MRI volume data
PACE_MRIvol <- read.delim("path\to\Freesurfer\volume\data",header = TRUE, sep = ",")

# Load neurocognition data
PACE_Cog <- read_excel("path\to\Freesurfer\cognition\data")

# Load brain age values
load("path\to\Freesurfer\brain age gap\data")
PACE_brainage <- brain_age_corrected_df


#### MERGE TABLES ####

# Remove follow-up gaf and qlst from follow-up data (not needed in analysis, avoids two gaf and qlst columns after merger with baseline table)
PACE_fup <- PACE_fup[,!(names(PACE_fup) %in% c('gaf', 'qlst'))] 

# Merge baseline with follow-up according to PACE 400 id
PACE_clinical <- list(PACE_bl, PACE_fup) %>% reduce(inner_join, by="caseid")

PACE_all <- PACE_clinical # store data for cumulative hazard analysis

#### PREPARE CLINICAL DATA ####

# Remove subjects with not gaf or timepace information
PACE_clinical <- subset(PACE_clinical, !is.na(timepace))
PACE_clinical <- subset(PACE_clinical, !is.na(gaf))
PACE_clinical <- subset(PACE_clinical, !is.na(tc))
PACE_clinical <- subset(PACE_clinical, !is.na(cd))


# Calculate days until transition
PACE_clinical$transdays <- as.Date(as.character(PACE_clinical$enddate), format = "%Y-%m-%d") - as.Date(as.character(PACE_clinical$startdate), format = "%Y-%m-%d")

PACE_clinical$transmonths <- (as.yearmon(as.character(PACE_clinical$enddate), format = "%Y-%m-%d") - as.yearmon(as.character(PACE_clinical$startdate), format = "%Y-%m-%d"))*12

# Calculate UHR categories
PACE_clinical$pre.cond <- PACE_clinical$blips + 2*PACE_clinical$atten + 4*PACE_clinical$vulner
# Remove subject with no UHR category
PACE_clinical <- subset(PACE_clinical, !is.na(pre.cond))
# Code UHR category according to dominant condition (BLIPS -> Attenuated -> Family History)
PACE_clinical[PACE_clinical$pre.cond == 3 | PACE_clinical$pre.cond == 5  | PACE_clinical$pre.cond == 7, c('pre.cond')] <- 1
PACE_clinical[PACE_clinical$pre.cond == 6 , c('pre.cond')] <- 2
PACE_clinical[PACE_clinical$pre.cond == 4 , c('pre.cond')] <- 3

#### PREPARE NEUROCOGNITION TABLE ####

# Select neurocognition variables (age adjusted scales for Ward's subtests Arithmetic and Digit Symbol Coding)
PACE_neurocog <- PACE_Cog[,c('caseid','Ax1CodingASS','Ax1ArithASS')]

# Remove rows from MRI tables with less than 50%
PACE_neurocog <- PACE_neurocog[which(rowMeans(!is.na(PACE_neurocog)) > 0.5), ]
# Set subjects with missing Digit Symbol Coding or Arithmetic scores to NA
PACE_neurocog[PACE_neurocog$Ax1CodingASS < 0 & !is.na(PACE_neurocog$Ax1CodingASS), 'Ax1CodingASS'] <- NA
PACE_neurocog[PACE_neurocog$Ax1ArithASS < 0 & !is.na(PACE_neurocog$Ax1ArithASS), 'Ax1ArithASS'] <- NA
# Remove subjects with NA values
PACE_neurocog <- subset(PACE_neurocog, !is.na(Ax1CodingASS))
PACE_neurocog <- subset(PACE_neurocog, !is.na(Ax1ArithASS))

# Merge neurocogntion data with clinical data according to PACE 400 ID
PACE_neurocog <- list(PACE_clinical, PACE_neurocog) %>% reduce(inner_join, by="caseid")

# Remove duplicated rows
PACE_neurocog <- PACE_neurocog[!duplicated(PACE_neurocog$caseid), ]

#### PREPARE NEUROIMAGING TABLE ####

## Merge caseid and MRI quality data according to MRI ID
mriQC <- merge(PACE_MRIQC,caseid_MRI, by.x = "BaselineMRI", by.y = "BaselineMRI")

# Remove rows from MRI tables with less than 99% data prior to merging
PACE_MRIthick <- PACE_MRIthick[which(rowMeans(!is.na(PACE_MRIthick)) > 0.99), ]
PACE_MRIcurve <- PACE_MRIcurve[which(rowMeans(!is.na(PACE_MRIcurve)) > 0.99), ]
PACE_MRIsurf <- PACE_MRIsurf[which(rowMeans(!is.na(PACE_MRIsurf)) > 0.99), ]
PACE_MRIvol <- PACE_MRIvol[which(rowMeans(!is.na(PACE_MRIvol)) > 0.99), ]

# Join all MRI tables according to PACE 400 id
PACE_MRI <- list(PACE_MRIthick, PACE_MRIcurve, PACE_MRIsurf, PACE_MRIvol) %>% reduce(inner_join, by=c("caseid","ID"))

# Merge clinical and all three MRI tables (Quality Control, MRI values, and brainage)
PACE_MRI <- merge(PACE_MRI, mriQC, by.x = "caseid", by.y = "caseid")
PACE_MRI <- merge(PACE_MRI, PACE_brainage, by.x = "caseid", by.y = "caseid")
PACE_MRI <- merge(PACE_clinical, PACE_MRI, by.x = "caseid", by.y = "caseid")

# Only select subjects with good MRI quality 
PACE_MRI <- subset(PACE_MRI, QC == 1)

# Remove duplicated rows
PACE_MRI <- PACE_MRI[!duplicated(PACE_MRI$caseid), ]

# Encode MRI site variable

PACE_MRI[PACE_MRI$MRIsite == "RCH" & !is.na(PACE_MRI$MRIsite), "MRIsite"] <- 0
PACE_MRI[PACE_MRI$MRIsite == "RMH" & !is.na(PACE_MRI$MRIsite), "MRIsite"] <- 1
PACE_MRI[PACE_MRI$MRIsite == "RCH (Orig 1.5)" & !is.na(PACE_MRI$MRIsite), "MRIsite"] <- 0
PACE_MRI[PACE_MRI$MRIsite == "BRI" & !is.na(PACE_MRI$MRIsite), "MRIsite"] <- 3

PACE_MRI$MRIsite_cat <- as.numeric(PACE_MRI$MRIsite == 3)

#### PREPARE TABLES FOR PCA ANALYSIS ####
PACE_MRIthick <- merge(PACE_MRI[,c('caseid','MRIsite')], PACE_MRIthick, by.x = 'caseid')
PACE_MRIcurve <- merge(PACE_MRI[,c('caseid','MRIsite')], PACE_MRIcurve, by.x = 'caseid')
PACE_MRIsurf <- merge(PACE_MRI[,c('caseid','MRIsite')], PACE_MRIsurf, by.x = 'caseid')
PACE_MRIvol <- merge(PACE_MRI[,c('caseid','MRIsite')], PACE_MRIvol, by.x = 'caseid')

```

## Plot cumulative hazard functions

```{r, echo=FALSE}

PACE_all$transyear <- (as.yearmon(as.character(PACE_all$enddate), format = "%Y-%m-%d") - as.yearmon(as.character(PACE_all$startdate), format = "%Y-%m-%d"))

# Calculate UHR categories
PACE_all$uhr_group <- PACE_all$blips + 2*PACE_all$atten + 4*PACE_all$vulner

# Remove subject with no UHR category
PACE_all <- subset(PACE_all, !is.na(uhr_group))

# Code UHR category according to dominant condition (BLIPS -> Attenuated -> Family History)
PACE_all[PACE_all$uhr_group == 3 | PACE_all$uhr_group == 5  | PACE_all$uhr_group == 7, c('uhr_group')] <- 1
PACE_all[PACE_all$uhr_group == 6 , c('uhr_group')] <- 2
PACE_all[PACE_all$uhr_group == 4 , c('uhr_group')] <- 3

fit <- survfit(Surv(transyear, transtat) ~ uhr_group, data = PACE_all)

cumhaz_plot <- ggsurvplot(fit,
          conf.int = FALSE,
          pval = TRUE,
          pval.method = TRUE,
          log.rank.weights = "n",
          pval.coord = c(12.5,0.1),
          pval.method.coord = c(12.5,0.15),
          pval.method.size = 5,
          xlab = "Time in years",   # customize X axis label.
          break.time.by = 5,     # break X axis in time intervals by 200.
          ylab = "Cumulative hazard function for transitioning to FEP",
          legend.labs = c("BLIPS", "Attenuated psychosis", "Vulnerability"), 
          risk.table.col = "strata", # Change risk table color by groups
          ggtheme = theme_bw(), # Change ggplot2 theme
          palette = c("#1b9e77", "#d95f02", "#7570b3"), # check colorbrewer2.org for color palettes
          fun = "cumhaz")

cumhaz_plot

```


## Principal component analysis

Each structural map contains 34 variables each linked to a region of the brain. To reduce the dimension of the feature space, we applied principal component analysis (PCA). 
```{r, echo=FALSE}

# Split each domain in left and right hemisphere
PACE_MRIthick.caseid <- PACE_MRIthick$caseid
PACE_MRIthick.lh <- PACE_MRIthick[,c(2,4:(ceiling(ncol(PACE_MRIthick)/2)))]
PACE_MRIthick.rh <- PACE_MRIthick[,c(2,(ceiling(ncol(PACE_MRIthick)/2)+2):(ncol(PACE_MRIthick)-1))]

PACE_MRIcurve.caseid <- PACE_MRIcurve$caseid
PACE_MRIcurve.lh <- PACE_MRIcurve[,c(2,4:(ceiling(ncol(PACE_MRIcurve)/2)+1))]
PACE_MRIcurve.rh <- PACE_MRIcurve[,c(2,(ceiling(ncol(PACE_MRIcurve)/2)+2):(ncol(PACE_MRIcurve)))]

PACE_MRIsurf.caseid <- PACE_MRIsurf$caseid
PACE_MRIsurf.lh <- PACE_MRIsurf[,c(2, 4:(ceiling(ncol(PACE_MRIsurf)/2)))]
PACE_MRIsurf.rh <- PACE_MRIsurf[,c(2, (ceiling(ncol(PACE_MRIsurf)/2)+2):(ncol(PACE_MRIsurf)-1))]

PACE_MRIvol.caseid <- PACE_MRIvol$caseid
PACE_MRIvol.lh <- PACE_MRIvol[,c(2, 4:(ceiling(ncol(PACE_MRIvol)/2)+1))]
PACE_MRIvol.rh <- PACE_MRIvol[,c(2, (ceiling(ncol(PACE_MRIvol)/2)+2):(ncol(PACE_MRIvol)))]

```


Harmonize MRI data based on scanner site
```{r, echo=FALSE}

# Split each domain in left and right hemisphere
PACE_MRIthick.lh.harm <- ComBat(t(PACE_MRIthick.lh[,c(2:ncol(PACE_MRIthick.lh))]), PACE_MRIthick.lh$MRIsite, mod = PACE_MRI$transtat)
PACE_MRIthick.lh.harm <- as.data.frame(t(PACE_MRIthick.lh.harm))
PACE_MRIthick.rh.harm <- ComBat(t(PACE_MRIthick.rh[,c(2:ncol(PACE_MRIthick.rh))]), PACE_MRIthick.rh$MRIsite,  mod = PACE_MRI$transtat)
PACE_MRIthick.rh.harm <- as.data.frame(t(PACE_MRIthick.rh.harm))

PACE_MRIcurve.lh.harm <- ComBat(t(PACE_MRIcurve.lh[,c(2:ncol(PACE_MRIcurve.lh))]), PACE_MRIcurve.lh$MRIsite,  mod = PACE_MRI$transtat)
PACE_MRIcurve.lh.harm <- as.data.frame(t(PACE_MRIcurve.lh.harm))
PACE_MRIcurve.rh.harm <- ComBat(t(PACE_MRIcurve.rh[,c(2:ncol(PACE_MRIcurve.rh))]), PACE_MRIcurve.rh$MRIsite,  mod = PACE_MRI$transtat)
PACE_MRIcurve.rh.harm <- as.data.frame(t(PACE_MRIcurve.rh.harm))

PACE_MRIsurf.lh.harm <- ComBat(t(PACE_MRIsurf.lh[,c(2:ncol(PACE_MRIsurf.lh))]), PACE_MRIsurf.lh$MRIsite,  mod = PACE_MRI$transtat)
PACE_MRIsurf.lh.harm <- as.data.frame(t(PACE_MRIsurf.lh.harm))
PACE_MRIsurf.rh.harm <- ComBat(t(PACE_MRIsurf.rh[,c(2:ncol(PACE_MRIsurf.rh))]), PACE_MRIsurf.rh$MRIsite,  mod = PACE_MRI$transtat)
PACE_MRIsurf.rh.harm <- as.data.frame(t(PACE_MRIsurf.rh.harm))

PACE_MRIvol.lh.harm <- ComBat(t(PACE_MRIvol.lh[,c(2:ncol(PACE_MRIvol.lh))]), PACE_MRIvol.lh$MRIsite,  mod = PACE_MRI$transtat)
PACE_MRIvol.lh.harm <- as.data.frame(t(PACE_MRIvol.lh.harm))
PACE_MRIvol.rh.harm <- ComBat(t(PACE_MRIvol.rh[,c(2:ncol(PACE_MRIvol.rh))]), PACE_MRIvol.rh$MRIsite,  mod = PACE_MRI$transtat)
PACE_MRIvol.rh.harm <- as.data.frame(t(PACE_MRIvol.rh.harm))

```



Calculate PCA values and select only the first component for each hemisphere

```{r, echo=FALSE}

#### Calculate PCA for each domain and hemisphere ####

# Thickness
PACE_MRIthick.pcalh <- prcomp(PACE_MRIthick.lh[, c(2:ncol(PACE_MRIthick.lh))], center = TRUE,scale. = TRUE, rank.=10)
PACE_MRIthick.pcarh <- prcomp(PACE_MRIthick.rh[, c(2:ncol(PACE_MRIthick.rh))], center = TRUE,scale. = TRUE, rank.=10)
# Select the first thickness PCA for each hemisphere
MRI.thick <- as.data.frame(cbind(PACE_MRIthick.caseid, PACE_MRIthick.pcalh$x[,'PC1'], PACE_MRIthick.pcarh$x[,'PC1']))
# Rename selected PCAs
colnames(MRI.thick) <- c('caseid', 'thickness_lh', 'thickness_rh')


# Volume
PACE_MRIvol.pcalh <- prcomp(PACE_MRIvol.lh[, c(2:ncol(PACE_MRIvol.lh))], center = TRUE,scale. = TRUE, rank.=10)
PACE_MRIvol.pcarh <- prcomp(PACE_MRIvol.rh[, c(2:ncol(PACE_MRIvol.rh))], center = TRUE,scale. = TRUE, rank.=10)
# Select the first volume PCA for each hemisphere
MRI.vol <- as.data.frame(cbind(PACE_MRIvol.caseid, PACE_MRIvol.pcalh$x[,'PC1'], PACE_MRIvol.pcarh$x[,'PC1']))
# Rename selected PCAs
colnames(MRI.vol) <- c('caseid', 'volume_lh', 'volume_rh')


# Surface area
PACE_MRIsurf.pcalh <- prcomp(PACE_MRIsurf.lh[, c(2:ncol(PACE_MRIsurf.lh))], center = TRUE,scale. = TRUE, rank.=10)
PACE_MRIsurf.pcarh <- prcomp(PACE_MRIsurf.rh[, c(2:ncol(PACE_MRIsurf.rh))], center = TRUE,scale. = TRUE, rank.=10)
# Select the first surface area PCA for each hemisphere
MRI.surf <- as.data.frame(cbind(PACE_MRIsurf.caseid, PACE_MRIsurf.pcalh$x[,'PC1'], PACE_MRIsurf.pcarh$x[,'PC1']))
# Rename selected PCAs
colnames(MRI.surf) <- c('caseid', 'surface_lh', 'surface_rh')


# Curvature
PACE_MRIcurve.pcalh <- prcomp(PACE_MRIcurve.lh[, c(2:ncol(PACE_MRIcurve.lh))], center = TRUE,scale. = TRUE, rank.=10)
PACE_MRIcurve.pcarh <- prcomp(PACE_MRIcurve.rh[, c(2:ncol(PACE_MRIcurve.rh))], center = TRUE,scale. = TRUE, rank.=10)
# Select the first curvature PCA for each hemisphere
MRI.curve <- as.data.frame(cbind(PACE_MRIcurve.caseid, PACE_MRIcurve.pcalh$x[,'PC1'], PACE_MRIcurve.pcarh$x[,'PC1']))
# Rename selected PCAs
colnames(MRI.curve) <- c('caseid', 'curvature_lh', 'curvature_rh')

# Merge all selected MRI principal components
MRI.all <- merge(MRI.thick, MRI.vol, by.x = "caseid", by.y = "caseid")
MRI.all <- merge(MRI.all, MRI.curve, by.x = "caseid", by.y = "caseid")
MRI.all <- merge(MRI.all, MRI.surf, by.x = "caseid", by.y = "caseid")

# Merge MRI commponents with PACE data
PACE_MRI <- merge(PACE_MRI, MRI.all, by.x = "caseid", by.y = "caseid")
```


Calculate PCA values with harmonized data and select only the first component for each hemisphere

```{r, echo=FALSE}

#### Calculate PCA for each domain and hemisphere ####

# Thickness
PACE_MRIthick.pcalh.harm <- prcomp(PACE_MRIthick.lh.harm, center = TRUE,scale. = TRUE, rank.=10)
PACE_MRIthick.pcarh.harm <- prcomp(PACE_MRIthick.rh.harm, center = TRUE,scale. = TRUE, rank.=10)
# Select the first thickness PCA for each hemisphere
MRI.thick <- as.data.frame(cbind(PACE_MRIthick.caseid, PACE_MRIthick.pcalh.harm$x[,'PC1'], PACE_MRIthick.pcarh.harm$x[,'PC1']))
# Rename selected PCAs
colnames(MRI.thick) <- c('caseid', 'thickness_lh_harm', 'thickness_rh_harm')


# Volume
PACE_MRIvol.pcalh.harm  <- prcomp(PACE_MRIvol.lh.harm, center = TRUE,scale. = TRUE, rank.=10)
PACE_MRIvol.pcarh.harm  <- prcomp(PACE_MRIvol.rh.harm, center = TRUE,scale. = TRUE, rank.=10)
# Select the first volume PCA for each hemisphere
MRI.vol <- as.data.frame(cbind(PACE_MRIvol.caseid, PACE_MRIvol.pcalh.harm$x[,'PC1'], PACE_MRIvol.pcarh.harm$x[,'PC1']))
# Rename selected PCAs
colnames(MRI.vol) <- c('caseid', 'volume_lh_harm', 'volume_rh_harm')


# Surface area
PACE_MRIsurf.pcalh.harm  <- prcomp(PACE_MRIsurf.lh.harm, center = TRUE,scale. = TRUE, rank.=10)
PACE_MRIsurf.pcarh.harm  <- prcomp(PACE_MRIsurf.rh.harm, center = TRUE,scale. = TRUE, rank.=10)
# Select the first surface area PCA for each hemisphere
MRI.surf <- as.data.frame(cbind(PACE_MRIsurf.caseid, PACE_MRIsurf.pcalh.harm$x[,'PC1'], PACE_MRIsurf.pcarh.harm$x[,'PC1']))
# Rename selected PCAs
colnames(MRI.surf) <- c('caseid', 'surface_lh_harm', 'surface_rh_harm')


# Curvature
PACE_MRIcurve.pcalh.harm  <- prcomp(PACE_MRIcurve.lh.harm, center = TRUE,scale. = TRUE, rank.=10)
PACE_MRIcurve.pcarh.harm  <- prcomp(PACE_MRIcurve.rh.harm, center = TRUE,scale. = TRUE, rank.=10)
# Select the first curvature PCA for each hemisphere
MRI.curve <- as.data.frame(cbind(PACE_MRIcurve.caseid, PACE_MRIcurve.pcalh.harm$x[,'PC1'], PACE_MRIcurve.pcarh.harm$x[,'PC1']))
# Rename selected PCAs
colnames(MRI.curve) <- c('caseid', 'curvature_lh_harm', 'curvature_rh_harm')

# Merge all selected MRI principal components
MRI.all <- merge(MRI.thick, MRI.vol, by.x = "caseid", by.y = "caseid")
MRI.all <- merge(MRI.all, MRI.curve, by.x = "caseid", by.y = "caseid")
MRI.all <- merge(MRI.all, MRI.surf, by.x = "caseid", by.y = "caseid")

# Merge MRI commponents with PACE data
PACE_MRI <- merge(PACE_MRI, MRI.all, by.x = "caseid", by.y = "caseid")
```

Create PCA table

```{r, echo=FALSE}
pc <- data.frame(Thickness=double(),
                 Volume=double(), 
                 Surface=double(), 
                 Curve=double()) 

pc <- pca.table(pc, 1, PACE_MRIthick.pcalh, PACE_MRIthick.pcarh)
pc <- pca.table(pc, 4, PACE_MRIcurve.pcalh, PACE_MRIcurve.pcarh)
pc <- pca.table(pc, 2, PACE_MRIvol.pcalh, PACE_MRIvol.pcarh)
pc <- pca.table(pc, 3, PACE_MRIsurf.pcalh, PACE_MRIsurf.pcarh)
pc <- round(pc, 2)
row.names(pc) <- c(paste('PC', c(1:10), 'lh', sep=''), paste('PC', c(1:10), 'rh', sep=''))

pc2 <- data.frame(Thickness=double(),
                 Volume=double(), 
                 Surface=double(), 
                 Curve=double()) 

pc2 <- pca.table(pc2, 1, PACE_MRIthick.pcalh.harm, PACE_MRIthick.pcarh.harm)
pc2 <- pca.table(pc2, 4, PACE_MRIcurve.pcalh, PACE_MRIcurve.pcarh.harm)
pc2 <- pca.table(pc2, 2, PACE_MRIvol.pcalh.harm, PACE_MRIvol.pcarh.harm)
pc2 <- pca.table(pc2, 3, PACE_MRIsurf.pcalh.harm, PACE_MRIsurf.pcarh.harm)
pc2 <- round(pc2, 2)
row.names(pc2) <- c(paste('PC', c(1:10), 'lh', sep=''), paste('PC', c(1:10), 'rh', sep=''))

```

Show PCA table

```{r, echo=FALSE,  fig.height = 8, fig.width = 8, fig.align = "center"}
pc %>%
  kbl(caption = "Table 1: Proportion of variance [%] included in first 10 principal components of each hemisphere and structural map") %>%
  kable_classic(full_width = F, html_font = "Cambria") %>%
  pack_rows("Left hemisphere", 1, 10) %>%
  pack_rows("Right hemisphere", 11, 20)

pc2 %>%
  kbl(caption = "Table 1: Proportion of variance [%] included in first 10 principal components of each hemisphere and structural map") %>%
  kable_classic(full_width = F, html_font = "Cambria") %>%
  pack_rows("Left hemisphere", 1, 10) %>%
  pack_rows("Right hemisphere", 11, 20)
```


Boxplots of principal components categorised by MRI site

```{r, echo=FALSE,  fig.height = 8, fig.width = 8, fig.align = "center"}

plot_thickness <- ggplot(PACE_MRI, aes(x=factor(MRIsite), y=thickness_lh, fill=as.factor(transtat)))+
  geom_boxplot() +
  labs(fill='Transition status') + 
  ggtitle("Original values") +
  scale_y_continuous(breaks=c(seq(-10,10,1)), limits = c(-10, 10))+
  labs(x="MRI site", y="Thickness left hemisphere PCA score") +
  scale_x_discrete(labels=c("RCH","RMH", "BRI")) +
  scale_fill_brewer(labels=c('No Transition', 'Transition'), palette="Dark2") + 
  theme_minimal() +
  theme(plot.title = element_text(size=15, hjust = 0.5),
        axis.text.x = element_text(size = 10),
        axis.title.x = element_text(size = 15),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size =15),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 10)) 

plot_thickness_harm <- ggplot(PACE_MRI, aes(x=factor(MRIsite), y=thickness_lh_harm, fill=as.factor(transtat)))+
  geom_boxplot() +
  labs(fill='Transition status') + 
  ggtitle("Harmonized values") +
  scale_y_continuous(breaks=c(seq(-10,10,1)), limits = c(-10, 10))+
  labs(x="MRI site", y="Thickness left hemisphere PCA score") +
  scale_x_discrete(labels=c("RCH","RMH", "BRI")) +
  scale_fill_brewer(labels=c('No Transition', 'Transition'), palette="Dark2") + 
  theme_minimal() +
  theme(plot.title = element_text(size=15, hjust = 0.5),
        axis.text.x = element_text(size = 10),
        axis.title.x = element_text(size = 15),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size = 15),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 10)) 

ggarrange(plot_thickness, plot_thickness_harm, ncol = 2, legend = "bottom", common.legend = TRUE)

plot_thickness2 <- ggplot(PACE_MRI, aes(x=factor(MRIsite), y=lh_rostralmiddlefrontal_thickness, fill=as.factor(transtat)))+
  geom_boxplot() +
  labs(fill='Transition status') + 
  ggtitle("Left hemisphere") +
  scale_y_continuous(breaks=c(seq(-10,10,1)), limits = c(2, 4))+
  labs(x="MRI site", y="Thickness rostralmiddlefrontal") +
  scale_x_discrete(labels=c("RCH","RMH","RCH (Orig 1.5)", "BRI")) +
  scale_fill_brewer(palette="Dark2") + 
  theme_minimal() +
  theme(plot.title = element_text(size=10, hjust = 0.5),
        axis.text.x = element_text(size = 10),
        axis.title.x = element_text(size = 15),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size =15),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 10)) 

plot_thickness_harm2 <- ggplot(PACE_MRI, aes(x=factor(MRIsite), y=rh_rostralmiddlefrontal_thickness, fill=as.factor(transtat)))+
  geom_boxplot() +
  labs(fill='Transition status') + 
  ggtitle("Right hemisphere") +
  scale_y_continuous(breaks=c(seq(-10,10,1)), limits = c(2, 4))+
  labs(x="MRI site", y="Thickness rostralmiddlefrontal") +
  scale_x_discrete(labels=c("RCH","RMH","RCH (Orig 1.5)", "BRI")) +
  scale_fill_brewer(palette="Dark2") + 
  theme_minimal() +
  theme(plot.title = element_text(size=10, hjust = 0.5),
        axis.text.x = element_text(size = 10),
        axis.title.x = element_text(size = 15),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size = 15),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 10)) 


ggarrange(plot_thickness2, plot_thickness_harm2, ncol = 2, legend = "bottom", common.legend = TRUE)

plot_thickness_scatter <- ggplot(PACE_MRI, aes(x=lh_rostralmiddlefrontal_thickness, y=rh_rostralmiddlefrontal_thickness, color=as.factor(MRIsite), shape = as.factor(MRIsite)))+
  geom_point() +
  ggtitle("Right hemisphere") +
  scale_y_continuous(breaks=c(seq(2,4,1)), limits = c(2, 4))+
  scale_x_continuous(breaks=c(seq(2,4,1)), limits = c(2, 4))+
  labs(x="MRI site", y="Thickness rostralmiddlefrontal") +
  scale_fill_brewer(palette="Dark2") + 
  theme_minimal() +
  theme(plot.title = element_text(size=10, hjust = 0.5),
        axis.text.x = element_text(size = 10),
        axis.title.x = element_text(size = 15),
        axis.text.y = element_text(size = 10),
        axis.title.y = element_text(size = 15),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 10)) 
```


## Visualize PCA results

```{r, echo=FALSE}

pc_left <- pc[1:10,]*100
pc_left$x <- 1:10
pc_left_plot <- melt(pc_left, id.vars = "x")
pc_right <- pc[11:20,]*100
pc_right$x <- 1:10
pc_right_plot <- melt(pc_right, id.vars = "x")

pca_left_plot <- pca_plot(pc_left_plot, 'Left hemisphere')
pca_right_plot <- pca_plot(pc_right_plot, 'Right hemisphere')

ggarrange(pca_left_plot, pca_right_plot, ncol = 2, common.legend = TRUE, legend = "bottom")


# Thickness loading

thick.loading <- loading_plot(PACE_MRIthick.pcalh, PACE_MRIthick.pcarh, 'Thickness')
vol.loading <- loading_plot(PACE_MRIvol.pcalh, PACE_MRIvol.pcarh, 'Volume')
curve.loading <- loading_plot(PACE_MRIcurve.pcalh, PACE_MRIcurve.pcarh, 'Mean curvature')
surf.loading <- loading_plot(PACE_MRIsurf.pcalh, PACE_MRIsurf.pcarh, 'Area')

ggarrange(thick.loading, vol.loading, curve.loading, surf.loading, nrow = 4)

```

## Cox regression analysis

Cox model using clinical variables

```{r, echo=FALSE}
set.seed(12)
# Create empty data frames for regression results table
cox.table <- data.frame(hr1=double(),
                  p1=double(),
                  hr2=double(),
                 p2=double(),
                 hr3=double(),
                 p3=double(),
                 hr4=double(),
                 p4=double(),
                 hr5=double(),
                 p5=double(),
                 hr6=double(),
                 p6=double(),
                 LR_chisq=double(),
                 p = double(),
                 Fraction=double(),
                 cIndex=double()) 

# Create empty data frames for overfitting results table
overfit.table <- data.frame(delta_Dxy=double(),
                 delta_R2=double(), 
                 delta_slope=double())

dd <- datadist(PACE_MRI)
options(datadist='dd')

PACE_MRI$pre.cond <- relevel(as.factor(PACE_MRI$pre.cond),ref = 1)


cox.bl <- cph(Surv(transmonths, transtat) ~ timepace + gaf + pre.cond , x=TRUE, y=TRUE, surv = TRUE, time.inc = 2*12, data = PACE_MRI)
# Get bootstrapped model
bl.conf <- bootcov(cox.bl, B=1000, pr=TRUE)
LR.orig <- cox.bl$stats['Model L.R.']
cox.res <- cox_model(cox.bl, 1, cox.table, overfit.table)

bl.multi <- cph(Surv(transmonths, transtat) ~ timepace + gaf + pre.cond  + tc + cd, x=TRUE, y=TRUE, surv = TRUE, time.inc = 10*12, data = PACE_MRI)
cox.res <- cox_model(bl.multi, 2, cox.res[[1]], cox.res[[2]], bl.conf, LR.orig)

bl.multi <- cph(Surv(transmonths, transtat) ~ timepace + gaf + pre.cond + surface_lh_harm + surface_rh_harm , x=TRUE, y=TRUE, surv = TRUE, time.inc = 10*12, data = PACE_MRI)
cox.res <- cox_model(bl.multi, 3, cox.res[[1]], cox.res[[2]], bl.conf, LR.orig)

bl.multi <- cph(Surv(transmonths, transtat) ~ timepace + gaf + pre.cond + curvature_lh_harm + curvature_rh_harm , x=TRUE, y=TRUE, surv = TRUE, time.inc = 10*12, data = PACE_MRI)
cox.res <- cox_model(bl.multi, 4, cox.res[[1]], cox.res[[2]], bl.conf, LR.orig)

bl.multi <- cph(Surv(transmonths, transtat) ~ timepace + gaf + pre.cond + volume_lh_harm + volume_rh_harm , x=TRUE, y=TRUE, surv = TRUE, time.inc = 10*12, data = PACE_MRI)
cox.res <- cox_model(bl.multi, 5, cox.res[[1]], cox.res[[2]], bl.conf, LR.orig)

bl.multi <- cph(Surv(transmonths, transtat) ~ timepace + gaf + pre.cond + thickness_lh_harm + thickness_rh_harm , x=TRUE, y=TRUE, surv = TRUE, time.inc = 10*12, data = PACE_MRI)
cox.res <- cox_model(bl.multi, 6, cox.res[[1]], cox.res[[2]], bl.conf, LR.orig)

bl.multi <- cph(Surv(transmonths, transtat) ~ timepace + gaf + pre.cond + corrected_gap + age_bl , x=TRUE, y=TRUE, surv = TRUE, time.inc = 10*12, data = PACE_MRI)
cox.res <- cox_model(bl.multi, 7, cox.res[[1]], cox.res[[2]], bl.conf, LR.orig)

cox.table <- cox.res[[1]]
overfit.table <- cox.res[[2]]

```

```{r, echo=FALSE}
cox.table <- round(cox.table, digits = 3)
overfit.table <- round(overfit.table, digits = 3)

row.names(overfit.table) <- c('Clinical','Clinical + Caarms','Clinical + MRI surface','Clinical + MRI curve', 'Clinical + MRI volume', 'Clinical + MRI thickness', 'Clinical + brain age')

row.names(cox.table) <- c('Clinical','Clinical + Caarms','Clinical + MRI surface','Clinical + MRI curve', 'Clinical + MRI volume', 'Clinical + MRI thickness', 'Clinical + brain age')

colnames(cox.table) <- c('HR timepace', 'P timepace', 'HR gaf','P gaf', 'HR UHR','P UHR', 'HR2 UHR', 'P UHR', 'HR 4', 'P 4', 'HR 5', 'P 5', 'LR', 'LR P', 'Fraction of new information', 'C index')

colnames(overfit.table) <- c('Optimism Dxy','Optimism R2','Optimism Slope')
```


Table lists the Cox model fit measures (Somer's D~xy, R)

```{r, echo=FALSE,  fig.height = 8, fig.width = 8, fig.align = "center"}
cox.table %>%
  kbl(caption = "Table 2: Comparison of model fit measures between nested models using Caarms, cognition, and structural imaging data") %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

## Calibration

```{r, echo=FALSE,  fig.height = 7, fig.width = 7, fig.align = "center"}

year2_plot <- calibration_plot(Surv(PACE_MRI$transmonths, PACE_MRI$transtat), PACE_MRI$timepace, PACE_MRI$gaf, PACE_MRI$cd, PACE_MRI$tc, PACE_MRI$pre.cond, PACE_MRI$corrected_gap, PACE_MRI$age_bl, 2)
#year5_plot <- calibration_plot(timepace, gaf, caarms.cd, caarms.tc, pre.cond, pc1.thick, pc2.thick, 2)
#year10_plot <- calibration_plot(timepace, gaf, caarms.cd, caarms.tc, pre.cond, pc1.thick, pc2.thick, 2)

year2_plot
#year5_plot
#year10_plot


cal_plot <- calibration_plot_all(Surv(PACE_MRI$transmonths, PACE_MRI$transtat), PACE_MRI$timepace, PACE_MRI$gaf, PACE_MRI$corrected_gap, PACE_MRI$age_bl, PACE_MRI$pre.cond)

cal_plot
```

Cox Model using clinical variables and neurocognition variables

```{r, echo=FALSE}

# Create empty data frames for regression results table
cox.table <- data.frame(hr1=double(),
                  p1=double(),
                  hr2=double(),
                 p2=double(),
                 hr3=double(),
                 p3=double(),
                 hr4=double(),
                 p4=double(),
                 hr5=double(),
                 p5=double(),
                 hr6=double(),
                 p6=double(),
                 LR_chisq=double(),
                 p = double(),
                 Fraction=double(),
                 cIndex=double()) 

# Create empty data frames for overfitting results table
overfit.table <- data.frame(delta_Dxy=double(),
                 delta_R2=double(), 
                 delta_slope=double())

set.seed(12)

PACE_neurocog$pre.cond <- relevel(as.factor(PACE_neurocog$pre.cond),ref = 1)

dd <- datadist(PACE_neurocog)
options(datadist='dd')

cox.bl <- cph(Surv(transmonths, transtat) ~ timepace + gaf + pre.cond, x=TRUE, y=TRUE, surv = TRUE, time.inc = 10*12, data = PACE_neurocog)
# Get bootstrapped model
bl.conf <- bootcov(cox.bl, B=1000, pr=TRUE)
LR.orig <- cox.bl$stats['Model L.R.']
cox.res <- cox_model(cox.bl, 1, cox.table, overfit.table)

bl.multi <- cph(Surv(transmonths, transtat) ~ timepace + gaf + pre.cond + tc + cd, x=TRUE, y=TRUE, surv = TRUE, time.inc = 10*12, data = PACE_neurocog)
cox.res <- cox_model(bl.multi, 2, cox.res[[1]], cox.res[[2]], bl.conf, LR.orig)

bl.multi <- cph(Surv(transmonths, transtat) ~ timepace + gaf + pre.cond + Ax1CodingASS + Ax1ArithASS, x=TRUE, y=TRUE, surv = TRUE, time.inc = 10*12, data = PACE_neurocog)
cox.res <- cox_model(bl.multi, 3, cox.res[[1]], cox.res[[2]], bl.conf, LR.orig)

cox.table <- cox.res[[1]]
overfit.table <- cox.res[[2]]

```


```{r, echo=FALSE}
cox.table <- round(cox.table, digits = 3)
overfit.table <- round(overfit.table, digits = 3)

row.names(overfit.table) <- c('Clinical','Clinical + Caarms','Clinical + Neurocognition')

row.names(cox.table) <- c('Clinical','Clinical + Caarms','Clinical + Neurocognition')

colnames(cox.table) <- c('HR timepace', 'P timepace', 'HR gaf','P gaf', 'HR UHR','P UHR', 'HR2 UHR', 'P UHR', 'HR 4', 'P 4', 'HR 5', 'P 5', 'LR', 'LR P', 'Fraction of new information', 'C index')

colnames(overfit.table) <- c('Optimism Dxy','Optimism R2','Optimism Slope')
```


Table lists the Cox model fit measures (Somer's D~xy, R)

```{r, echo=FALSE,  fig.height = 8, fig.width = 8, fig.align = "center"}
cox.table %>%
  kbl(caption = "Table 2: Comparison of model fit measures between nested models using Caarms, cognition, and structural imaging data") %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

## Calibration

```{r, echo=FALSE,  fig.height = 7, fig.width = 7, fig.align = "center"}

year2_plot <- calibration_plot(Surv(PACE_neurocog$transmonths, PACE_neurocog$transtat), PACE_neurocog$timepace, PACE_neurocog$gaf, PACE_neurocog$cd, PACE_neurocog$tc, PACE_neurocog$pre.cond, PACE_neurocog$Ax1CodingASS, PACE_neurocog$Ax1ArithASS, 2)


year2_plot

```

